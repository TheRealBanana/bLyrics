# encoding: utf-8
#bLyrics_COM.pyw - by Kyle Claisse - 2013
#
#This is the main part of fooBarLyrics app.
#The entire app is:
# bLyrics_COM.pyw
# fooBarLyrics.py
# lyricswiki.py
# about_pane.py
#
#
# Revision 010
# Last Modified: July 24, 2014
#

import sys
from PyQt4 import QtCore, QtGui, QtWebKit
from fooBarLyrics import lyricsClass
from about_pane import *
from options_dialog import *
from manualQueryDialog import *
from icon_resource import *
from time import time as tTime
from datetime import datetime as dTime
from re import split as REsplit
from re import sub as REsub

#To force this program to always be on top of other windows change this to True
_ALWAYS_ON_TOP_ = False

try:
	_fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
	def _fromUtf8(s):
		return s

try:
	_encoding = QtGui.QApplication.UnicodeUTF8
	def _translate(context, text, disambig):
		return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
	def _translate(context, text, disambig):
		return QtGui.QApplication.translate(context, text, disambig)




class Ui_MainWindow(object):
	def setupUi(self, MainWindow):
		#just a few class globals
		self.output = [dTime.fromtimestamp(tTime()).strftime('%d/%b/%Y-%I:%M:%S %p:   ') + "PROGRAM_INIT"]
		self.is_connected = False
		self.windowTitle = None
		self.timer = None
		self.lyricsProg = lyricsClass(self)
		self.currentSong = None
		self.last_sb_message = None
		#Set up the name of our app and the company name for saving settings later
		#We also tell it to save as an INI file in %APPDATA% (the default location)
		self.appSettings = QtCore.QSettings(QtCore.QSettings.IniFormat, QtCore.QSettings.UserScope, "Kylesplace.org", "bLyrics")
		#Need this to load options without excess code
		self.optionsWindowui = Ui_OptionsDialog()
		self.webStatus_URL = ""
		#Some default settings for the appearance
		self.fontStyle = 'MS Shell Dlg 2, 8'
		self.fontFgColor = '#000000'
		self.fontBgColor = '#FFFFFF'
		
		
		##Setting up the GUI, most of this was autogenerated by Qt Designer
		MainWindow.setObjectName(_fromUtf8("MainWindow"))
		MainWindow.resize(559, 673)
		MainWindow.setMinimumSize(QtCore.QSize(550, 650))
		#Set the icon
		MainWindow.setWindowIcon(QtGui.QIcon(":/icon/bLyrics.ico"))
		self.centralwidget = QtGui.QWidget(MainWindow)
		self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
		self.gridLayout = QtGui.QGridLayout(self.centralwidget)
		self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
		self.tabWidget = QtGui.QTabWidget(self.centralwidget)
		self.tabWidget.setObjectName(_fromUtf8("tabWidget"))
		self.MainTab = QtGui.QWidget()
		self.MainTab.setObjectName(_fromUtf8("MainTab"))
		self.gridLayout_2 = QtGui.QGridLayout(self.MainTab)
		self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
		self.MainStatusWebView = QtWebKit.QWebView(self.MainTab)
		#self.MainStatusWebView.setUrl(QtCore.QUrl(_fromUtf8("http://127.0.0.1:8888/ajquery/index.html")))  #This is going to change to custom HTML page that says to adjust the options
		self.MainStatusWebView.setObjectName(_fromUtf8("MainStatusWebView"))
		self.gridLayout_2.addWidget(self.MainStatusWebView, 0, 0, 1, 1)
		self.tabWidget.addTab(self.MainTab, _fromUtf8(""))
		self.LyricsTab = QtGui.QWidget()
		self.LyricsTab.setObjectName(_fromUtf8("LyricsTab"))
		#lyrics tab context menu
		self.LyricsTab.setContextMenuPolicy(QtCore.Qt.NoContextMenu)
		######
		self.gridLayout_3 = QtGui.QGridLayout(self.LyricsTab)
		self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
		self.lyricsTextView = QtGui.QTextBrowser(self.LyricsTab)
		self.lyricsTextView.setObjectName(_fromUtf8("lyricsTextView"))
		#self.lyricsTextView.setContextMenuPolicy(QtCore.Qt.NoContextMenu)   # Disables context menu in lyrics box. Users can still ctrl+c
		self.gridLayout_3.addWidget(self.lyricsTextView, 0, 0, 1, 2)
		self.RefreshLyricsButton = QtGui.QPushButton(self.LyricsTab)
		self.RefreshLyricsButton.setObjectName(_fromUtf8("RefreshLyricsButton"))
		self.gridLayout_3.addWidget(self.RefreshLyricsButton, 1, 0, 1, 1)
		spacerItem = QtGui.QSpacerItem(433, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
		self.gridLayout_3.addItem(spacerItem, 1, 1, 1, 1)
		self.tabWidget.addTab(self.LyricsTab, _fromUtf8(""))
		
		self.ConsoleTab = QtGui.QWidget()
		self.ConsoleTab.setObjectName(_fromUtf8("ConsoleTab"))
		self.gridLayout_4 = QtGui.QGridLayout(self.ConsoleTab)
		self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
		self.consoleOutput = QtGui.QTextBrowser(self.ConsoleTab)
		self.virtScrollBar = self.consoleOutput.verticalScrollBar()
		self.consoleOutput.setObjectName(_fromUtf8("consoleOutput"))
		self.gridLayout_4.addWidget(self.consoleOutput, 0, 0, 1, 2)
		self.consoleO_ClearButton = QtGui.QPushButton(self.ConsoleTab)
		self.consoleO_ClearButton.setObjectName(_fromUtf8("consoleO_ClearButton"))
		self.gridLayout_4.addWidget(self.consoleO_ClearButton, 1, 0, 1, 1)
		spacerItem1 = QtGui.QSpacerItem(424, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
		self.gridLayout_4.addItem(spacerItem1, 1, 1, 1, 1)
		
		self.tabWidget.addTab(self.ConsoleTab, _fromUtf8(""))
		self.gridLayout.addWidget(self.tabWidget, 0, 0, 1, 1)
		
		#Our new QLabel statusbar
		self.Statusbar = QtGui.QLabel(self.centralwidget)
		statusBarFont = QtGui.QFont()
		statusBarFont.setFamily(_fromUtf8("Segoe UI"))
		statusBarFont.setPointSize(9)
		statusBarFont.setKerning(False)
		self.Statusbar.setFont(statusBarFont)
		self.Statusbar.setTextFormat(QtCore.Qt.AutoText)
		self.Statusbar.setAlignment(QtCore.Qt.AlignBottom|QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft)
		self.Statusbar.setObjectName(_fromUtf8("Statusbar"))
		self.gridLayout.addWidget(self.Statusbar, 2, 0, 1, 1)
		statusbarSpacer = QtGui.QSpacerItem(1, 4, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
		self.gridLayout.addItem(statusbarSpacer, 1, 0, 1, 1)
		
		MainWindow.setCentralWidget(self.centralwidget)
		self.menubar = QtGui.QMenuBar(MainWindow)
		self.menubar.setGeometry(QtCore.QRect(0, 0, 559, 21))
		self.menubar.setObjectName(_fromUtf8("menubar"))
		self.menuFile = QtGui.QMenu(self.menubar)
		self.menuFile.setObjectName(_fromUtf8("menuFile"))
		self.menuHelp = QtGui.QMenu(self.menubar)
		self.menuHelp.setObjectName(_fromUtf8("menuHelp"))
		MainWindow.setMenuBar(self.menubar)
		self.aboutMenuItem = QtGui.QAction(MainWindow)
		self.aboutMenuItem.setObjectName(_fromUtf8("aboutMenuItem"))
		self.menuHelp.addAction(self.aboutMenuItem)
		self.menubar.addAction(self.menuFile.menuAction())
		self.menubar.addAction(self.menuHelp.menuAction())
		
		self.actionReconnect = QtGui.QAction(MainWindow)
		self.actionReconnect.setObjectName(_fromUtf8("actionReconnect"))
		
		self.actionDisconnect = QtGui.QAction(MainWindow)
		self.actionDisconnect.setObjectName(_fromUtf8("actionDisconnect"))
		
		self.actionQuit = QtGui.QAction(MainWindow)
		self.actionQuit.setObjectName(_fromUtf8("actionQuit"))
		
		self.actionClearCache = QtGui.QAction(MainWindow)
		self.actionClearCache.setObjectName(_fromUtf8("actionClearCache"))
		
		self.actionOptions = QtGui.QAction(MainWindow)
		self.actionOptions.setObjectName(_fromUtf8("actionOptions"))
		
		#Create submenu
		self.subMenu = QtGui.QMenu(self.menuFile)
		self.subMenu.setObjectName(_fromUtf8("subMenu"))
		
		self.actionManualQuery = QtGui.QAction(MainWindow)
		self.actionManualQuery.setObjectName(_fromUtf8("actionManualQuery"))
		
		self.actionResetManualQuery = QtGui.QAction(MainWindow)
		self.actionResetManualQuery.setObjectName(_fromUtf8("actionResetManualQuery"))
		
		self.actionSearch = QtGui.QAction(MainWindow)
		self.actionSearch.setObjectName(_fromUtf8("actionSearch"))
		#build submenu
		self.subMenu.addAction(self.actionSearch)
		self.subMenu.addAction(self.actionManualQuery)
		self.subMenu.addAction(self.actionResetManualQuery)
		
		
		#Build file menu
		self.menuFile.addAction(self.actionReconnect)
		self.menuFile.addAction(self.actionDisconnect)
		self.menuFile.addSeparator()
		self.menuFile.addAction(self.actionClearCache)
		self.menuFile.addAction(self.actionOptions)
		self.menuFile.addSeparator()
		self.menuFile.addAction(self.subMenu.menuAction())
		self.menuFile.addSeparator()
		self.menuFile.addAction(self.actionQuit)
		
		#Build help menu
		self.menuHelp.addAction(self.aboutMenuItem)
		

		self.retranslateUi(MainWindow)
		self.tabWidget.setCurrentIndex(1)   #This sets the default tab, starting from 0 = current status tab, 1 = lyrics tab, and 2 = console
		
		#Load up settings the user saved such as window position, web interface url, debug mode, etc
		self.loadSettings()
		
		#Set up our slot connections
		QtCore.QObject.connect(self.RefreshLyricsButton, QtCore.SIGNAL(_fromUtf8("clicked()")), self.refreshLyrics_Operation)
		QtCore.QObject.connect(self.tabWidget, QtCore.SIGNAL(_fromUtf8("currentChanged(int)")), self.MainStatusWebView.reload)
		QtCore.QObject.connect(self.aboutMenuItem, QtCore.SIGNAL(_fromUtf8("triggered()")), self.openAboutWindow)
		QtCore.QObject.connect(self.actionQuit, QtCore.SIGNAL(_fromUtf8("triggered()")), MainWindow.close)
		QtCore.QObject.connect(self.actionReconnect, QtCore.SIGNAL(_fromUtf8("triggered()")), self.refreshLyrics_Operation)
		QtCore.QObject.connect(self.actionClearCache, QtCore.SIGNAL(_fromUtf8("triggered()")), self.lyricsProg.clear_playlist_cache)
		QtCore.QObject.connect(self.actionDisconnect, QtCore.SIGNAL(_fromUtf8("triggered()")), self.discon)
		QtCore.QObject.connect(self.actionOptions, QtCore.SIGNAL(_fromUtf8("triggered()")), self.openOptionsWindow)
		QtCore.QObject.connect(self.actionManualQuery, QtCore.SIGNAL(_fromUtf8("triggered()")), self.openManualQueryDialog)
		QtCore.QObject.connect(self.actionResetManualQuery, QtCore.SIGNAL(_fromUtf8("triggered()")), self.resetManualEntry)
		QtCore.QObject.connect(self.actionSearch, QtCore.SIGNAL(_fromUtf8("triggered()")), self.openSearchDialog)
		QtCore.QObject.connect(self.consoleO_ClearButton, QtCore.SIGNAL(_fromUtf8("clicked()")), self.clear_console)
		QtCore.QObject.connect(self.lyricsTextView, QtCore.SIGNAL(_fromUtf8("anchorClicked(QUrl)")), self.setSearchResult)
		#QtCore.QObject.connect(self.consoleOutput, QtCore.SIGNAL(_fromUtf8("sourceChanged(QUrl)")), self.keepConsoleScroll) #Not working for some reason
		QtCore.QMetaObject.connectSlotsByName(MainWindow)
		
		#Tell the user we're not connected
		self.setLyricsText("Not connected to Foobar2000's COM server, press refresh to try to connect.")		
		self.setWindowTitle("bLyrics  ::  Not Connected - Press Refresh or Connect")
		self.setStatusbarText("Disconnected from Foobar2000 COM Server")
		
		#Set up the internal loop that checks for a new song and retrieves lyrics when needed.
		if self.timer is None:
			self.timer = QtCore.QTimer()
			QtCore.QObject.connect(self.timer, QtCore.SIGNAL("timeout()"), self.check_song_loop)
		#timer.timeout.connect(self.check_song_loop)
		self.timer.start(5000)
		#And now we just manually execute the check_song_loop ourselves the first time instead of waiting 5s for the first iteration of the timer to finish.
		self.check_song_loop()

	def keepConsoleScroll(self):
		if self.virtScrollBar.maximum() > 0 :
			self.virtScrollBar.setValue(self.virtScrollBar.maximum())
		
		

	def discon(self, forced=False):
		self.actionReconnect.setText(_translate("MainWindow", "Connect", None))
		self.lyricsProg.end_com()
		self.is_connected = False
		self.setLyricsText("Not connected to Foobar2000's COM server, press refresh to try to connect.")		
		self.setWindowTitle("bLyrics  ::  Not Connected - Press Refresh or Connect")
		self.setStatusbarText("Disconnected from Foobar2000 COM Server")
	
	def openOptionsWindow(self):
		widget = QtGui.QDialog()
		self.optionsWindowui.setupUi(widget, self, _ALWAYS_ON_TOP_)
		if _ALWAYS_ON_TOP_:
			widget.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
		widget.setWindowIcon(QtGui.QIcon(":/icon/bLyrics.ico"))
		widget.exec_()
	
	def openSearchDialog(self):
		#Set tab to the search output before we do anything
		self.tabWidget.setCurrentIndex(1)
		widget = QtGui.QDialog()
		mQDialog = Ui_customQueryDialog()
		return_data = []
		mQDialog.setupUi(widget, return_data)
		if _ALWAYS_ON_TOP_:
			widget.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
		widget.setWindowTitle(_translate("customQueryDialog", "Search for lyrics", None))
		widget.setWindowIcon(QtGui.QIcon(":/icon/bLyrics.ico"))
		widget.exec_()
		#change to normal python strings
		if return_data != []:
			return_data = [str(z) for z in return_data]
		
		#Now we get the first page of results in the form of a list where each item is a dictionary with three parts: Artist, Song Title, and URL.
		if len(return_data) > 0:
			search_results = self.lyricsProg.searchForLyrics(song=return_data[1], artist=return_data[0])
		else:
			search_results = ""
		if len(search_results) > 0:
			result_html_template = '''
<p style="font-weight: normal; font-family: Tahoma, Geneva, sans-serif; font-size: 18px; font-weight: bold;">%s)<a href="%s"><span style="font-size: 14px;"> %s <span style="font-weight: normal;">by</span> %s</span></a></p>'''
			html_body = ""
			#We make an HTML page containing all the results for the user to select from.
			#First we build up the body of our html using result_html as a template
			for index, result_entry in enumerate(search_results):
				combined_url = "#%s::%s::%s" % (result_entry["url"], result_entry["title"], result_entry["artist"])
				html_body += result_html_template % (index+1, combined_url, result_entry["title"], result_entry["artist"])
			#Now we generate the main html
			main_html = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><title>Search Results</title></head><body><p style="font-family: Tahoma, Geneva, sans-serif; font-weight: bold; font-size: 24px;">%s LYRIC RESULTS:</p>
%s
</body></html>''' % (len(search_results), html_body)
			#And now we display the output to the user in the lyrics tab
			self.lyricsTextView.setHtml(_translate("MainWindow", main_html, None))
	
	def resetManualEntry(self):
		self.lyricsProg.resetManualEntry()
		self.currentSong = None
		self.check_song_loop(userasked=True)
		
	def setSearchResult(self, url):
		self.lyricsProg.manual_url_set(str(url.toString()[1:])) # cut off the beginning hash
		self.currentSong = None
		self.check_song_loop(userasked=True)
	
	def openManualQueryDialog(self):
		widget = QtGui.QDialog()
		mQDialog = Ui_customQueryDialog()
		return_data = []
		mQDialog.setupUi(widget, return_data)
		if _ALWAYS_ON_TOP_:
			widget.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
		widget.setWindowTitle(_translate("customQueryDialog", "Manual lyrics query", None))
		widget.setWindowIcon(QtGui.QIcon(":/icon/bLyrics.ico"))
		widget.exec_()
		#change to normal python strings
		return_data = [str(z) for z in return_data]
		#Now we need to let fooBarLyrics.py know we have a manual query so it doesnt just change the song back when it senses the change
		if return_data != []:
			self.lyricsProg.manual_song_set(return_data)
			#Now force the mainUI to update
			self.currentSong = None
			self.check_song_loop(userasked=True)
			
	
	def openAboutWindow(self):
		#self.widget = QtGui.QWidget()
		self.widget = QtGui.QDialog()
		self.aboutWindowui = Ui_aboutWindow()
		self.aboutWindowui.setupUi(self.widget)
		self.widget.setWindowIcon(QtGui.QIcon(":/icon/bLyrics.ico"))
		#self.widget.show()
		#Set the window to be always on top if always-on-top is enabled
		if _ALWAYS_ON_TOP_:
			self.widget.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
		self.widget.exec_()
	
	def saveSettings(self, optionsMenu=False, data=[]):
		#This will just go ahead and save everything unless told not to
		if optionsMenu is True:
			#Ok we are receiving data from the options menu.
			#The data list is a list of three dictionaries, each one holding
			#settings from its respective page. Index 0 being the first page
			#and so-on.
			self.appSettings.beginGroup("Options")
			for index in xrange(len(data)):
				#Begin the appropriate group
				if index == 0:
					self.appSettings.beginGroup("Appearance")
				if index == 1:
					self.appSettings.beginGroup("fb2kServerInfo")
				if index == 2:
					self.appSettings.beginGroup("Advanced")
					
				#start stuffing data in
				for key,val in data[index].iteritems():
					self.appSettings.setValue(key, val)
				
				#End the group and get to the next one
				self.appSettings.endGroup()

			#Now that we're done iterating over the data we can sync it and finish
			self.appSettings.endGroup()
			#Now we update the Ui
			optionsdict = {}
			optionsdict["Appearance"] = [data[0]["fontNameAndSize"], data[0]["bgFontColor"], data[0]["fgFontColor"]]
			optionsdict["fb2kServerInfo"] = [data[1]["address"], data[1]["port"], data[1]["userpassreq"], data[1]["user"], data[1]["pass"], [data[1]["installedTemplates"][0], data[1]["installedTemplates"][1], data[1]["installedTemplates"][2]]]
			optionsdict["Advanced"] = [data[2]["debugModeEnabled"], data[2]["debugWriteEnabled"], data[2]["debugOutputFolder"], data[2]["cacheAge"], data[2]["masterMatchRatio"], data[2]["alwaysOnTop"]]
			self.setupUiOptions(optionsdict)
		
		#Begin group for basic app settings
		self.appSettings.beginGroup("WindowState")
		#Screen size and position
		self.appSettings.setValue("windowSize", MainWindow.size())
		self.appSettings.setValue("windowPos", MainWindow.pos())		
		self.appSettings.endGroup()
		self.appSettings.sync()

	def testSettingGroup(self, groupName):
		#The reason we join() and then split() is because it's a quick way to convert a QStringList,
		#containing a bunch of QStrings, all into a single string at once without adding iteration.
		for x in str(self.appSettings.allKeys().join(";")).split(";"): #Why join and resplit?
			if groupName in x:
				#We are sure the group exists so we can continue
				return True
	
	def resetSettings(self):
		self.appSettings.clear()

	def loadSettings(self, optionsMenu=False, data={}):
		#data is a dictionary where the key is the subgroup and the value is a list containing the key(s) we are looking for
		# Example: passing this:  data["LastAppState"] = ["windowPos"]
		#          would return the saved window position
		#If you want more than one key from a subgroup then just include it in the list
		# Example: passing this:  data["LastAppState"] = ["windowSize", "windowsPos"]
		#          would return both the saved size and the position.
		
		#Options menu is asking for the user's saved settings
		if optionsMenu is True:
			self.appSettings.beginGroup("Options")
			returnData = {}
			#loop through data{} and get the values requested. Each key is the subgroup name.
			for key in data:
				returnData[key] = []
				self.appSettings.beginGroup(key)
				#loop through the list of values to return and get the data
				for value in data[key]:
					if value == "installedTemplates": #this one is fucky so we have to plan for it specifically
						temp = self.appSettings.value(value).toStringList()
						niceVal = []
						for x in xrange(len(temp)):
							niceVal.append(str(temp[x]))
					else:
						niceVal = str(self.appSettings.value(value).toPyObject())
					returnData[key].append(niceVal)
				self.appSettings.endGroup()
			
			self.appSettings.endGroup()
			
			#We should have a nice dictionary with all the requested data in it so just return
			return returnData
		
		#We have a ton of settings to load and set so lets start with the basics
		#Load up the window size and position if they exist
		if self.testSettingGroup("WindowState") is True:
			self.appSettings.beginGroup("WindowState")
			MainWindow.resize(self.appSettings.value("windowSize").toSize())
			MainWindow.move(self.appSettings.value("windowPos").toPoint())
			self.appSettings.endGroup()
		#Now we load up our options if they exist, if not we create it and set the defaults.
		if self.testSettingGroup("Options") is True:
			#Load up the settings using the options window's loadOptions function
			loadedOptions = self.optionsWindowui.loadOptions(external=True, MW=self)
			self.setupUiOptions(loadedOptions)
		else:
			defaults = {'Appearance': ['MS Shell Dlg 2, 8', '#FFFFFF', '#000000'], 'fb2kServerInfo': ['127.0.0.1', '8888', False, '', '', [False, True, False]], 'Advanced': [False, False, '', '15', '0.65', True]}
			self.setupUiOptions(defaults)
		
			
		
	def setupUiOptions(self, options):
		#Set the templates installed
		self.templates = [options["fb2kServerInfo"][5][0], options["fb2kServerInfo"][5][1], options["fb2kServerInfo"][5][2]]
		
		self.webStatus_URL = "http://"
		#Set up the options we've been given
		
		#First we set the status page url with the given info.
		#Credentials
		if options["fb2kServerInfo"][2] == True: self.webStatus_URL += "%s:%s@" % (options["fb2kServerInfo"][3], options["fb2kServerInfo"][4])
		#IP and port
		self.webStatus_URL += "%s:%s/" % (options["fb2kServerInfo"][0], options["fb2kServerInfo"][1])
		#Choose template, prefer aJquery
		if options["fb2kServerInfo"][5][1] is True: self.webStatus_URL += "ajquery/index.html"
		elif options["fb2kServerInfo"][5][0] is True: self.webStatus_URL += "default/"
		elif options["fb2kServerInfo"][5][2] is True: self.webStatus_URL += "foobar2000controller/"
		#Set the URL
		self.MainStatusWebView.setUrl(QtCore.QUrl(_fromUtf8(self.webStatus_URL)))
		
		#Now we set the user-defined appearance settings.
		self.fontStyle = options["Appearance"][0]
		self.fontBgColor = options["Appearance"][1]
		self.fontFgColor = options["Appearance"][2]
		
		#Now on to the advanced page
		lwop = {}
		#Set the debug mode/write mode
		lwop["debugModeEnabled"] = options["Advanced"][0]
		lwop["debugWriteEnabled"] = options["Advanced"][1]
		lwop["debugOutputFolder"] = options["Advanced"][2]
		lwop["masterMatchRatio"] = options["Advanced"][4]
		self.lyricsProg.setLWOps(lwop)
		
		#Set the cache age
		age_in_seconds = int(options["Advanced"][3]) * 60
		self.lyricsProg.setCacheAge(age_in_seconds)
		
		
	
	def refreshLyrics_Operation(self):
		#OK so once in a while something happens and everything trainwrecks, not sure exactly what sets it off.
		#It appears to happen in one out of every few hundred or more songs and is only apparent for one song.
		#The refresh button should fix this problem and to facilitate this we must preform a "hard reset" on all internal operations and then restart everything again. All in one button.
		#
		#This is also the function that gets everything started, the user must connect to the foobar COM server through here before any lyrics pop up.
		print "Doing a hard refresh of lyrics...."
		self.setLyricsText("Refreshing lyrics....")
		
		#Reset any manual/search mode
		self.resetManualEntry()
		
		#Reset connection to com server
		if self.lyricsProg.try_com():
			self.is_connected = True
			self.actionReconnect.setText(_translate("MainWindow", "Reconnect", None))
		else:
			self.is_connected = False
			self.actionReconnect.setText(_translate("MainWindow", "Connect", None))
	
		#Reset internal variables to force the main loop to redo everything as if we changed songs.
		self.currentSong = None
		
		#If we are really connected to the foobar COM server, reload the status tab:
		if self.lyricsProg.fbcom_Playback is not None:
			#Update the main view now that we are sure we are connected
			self.MainStatusWebView.setUrl(QtCore.QUrl(_fromUtf8(self.webStatus_URL)))
			self.MainStatusWebView.reload()
		
		#And now sent it back into the main loop to redo everything.
		self.check_song_loop()
	
	
	def clear_console(self):
		self.output = []
		html = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"></p></body></html>
'''
		self.consoleOutput.setHtml(_translate("MainWindow", html, None))
		
	def write(self, text):
		#This function allows us to set stderr and stdout to write to this function instead of the usual output.
		#That way any time a print or error occurs it will be output to this function, which will write to the console tab.
		if text.strip() != "":
			if text != "__PROGAMINIT__":
				timestamp = dTime.fromtimestamp(tTime()).strftime('%d/%b/%Y-%I:%M:%S %p:   ')
				text = timestamp + text
				self.output.append(text)

			final_output = ""
			for entry in self.output:
				final_output = final_output + str(entry) + "<br>"
			
			
			html = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">%s</p></body></html>
''' % (final_output)
			self.consoleOutput.setHtml(_translate("MainWindow", html, None))
			self.keepConsoleScroll() #Chuck this function call, and the function itself. It isn't working. Just make sure it doesnt break anything in the process
	
	def setWindowTitle(self, text):
		MainWindow.setWindowTitle(_translate("MainWindow", text, None))
		self.windowTitle = text
	
	
	
	#This function is a MESS! CLEAN IT UP!
	def check_song_loop(self, userasked=False):
		#Just return if we haven't connected yet
		if self.is_connected == False and userasked == False:
			return

		#first thing will be to check if we have a current song, and if we do whether it has changed or not
		if self.currentSong is None:
			#Ok we don't have a song yet so lets set it for the first time.
			#We use a combination of the song name and the first letter of the artist's name to avoid trouble with two artists having the same song name
			current_song_data = self.lyricsProg.get_songartist()
			self.currentSong = "%s%s" % (current_song_data[1], current_song_data[0][0])
			#And now update the lyrics page if there is a song playing
			if self.currentSong != "stops":
				self.setLyricsText("Looking for lyrics....")
				self.currentLyrics = self.lyricsProg.getLatestLyrics()
				if self.currentLyrics is None:
					#Lost connect to the COM server
					self.setLyricsText("Not connected to Foobar2000's COM server, press refresh to try to connect.")
					#End the connection internally
					self.discon(forced=True)
					self.setWindowTitle("bLyrics  ::  Not Connected - Press Refresh or Connect")
					self.actionReconnect.setText(_translate("MainWindow", "Connect", None))
					#And reset the current song
					self.currentSong = None
				else:
					#and set the global current song var to whats currently playing
					self.currentSong = "%s%s" % (self.lyricsProg.get_songartist()[1], self.lyricsProg.get_songartist()[0][0]) #Full song title plus first letter of the artist
					#clean up song name
					self.currentSong = self.currentSong.replace("\\", "")
					self.currentSong = self.currentSong.replace("\\", "")
					#And now we update the lyrics page with the new lyrics
					self.setLyricsText(self.currentLyrics)
					#Set the statusbar to the current song or the next song, depending on factors. See fooBarLyrics.py for more details.
					statusbar_songdata = self.lyricsProg.get_statusbar_song(templates=self.templates)
					self.setStatusbarText(statusbar_songdata)
					#We also update the window title to reflect the new track and artist
					self.setWindowTitle("bLyrics  ::  %s - %s" % (self.lyricsProg.get_songartist()))
			else:
				#Foobar is currently stopped so we need to update the app to reflect this
				#First we update the lyrics pane with the info
				self.setLyricsText("Playing in Foobar2000 is currently stopped.")
				#update the statusbar with the change
				self.setStatusbarText("Playback Stopped")
				#And the window title next
				self.setWindowTitle("bLyrics  ::  Playback Stopped")
				#return 1
		#Now we are sure self.currentSong is set so lets check if its the same song or not.
		
		actual_current_song = None
		while actual_current_song is None:
			try:
				song_artist_data = self.lyricsProg.get_songartist()
				actual_current_song = "%s%s" % (song_artist_data[1], song_artist_data[0][0])
			except:
				actual_current_song = None
		
		if actual_current_song != self.currentSong and userasked == False:
			#ok the current song isn't the same as the one we had set so the song has changed, we need to update everything to reflect that
			#This is usually where things go south if the lyrics don't exist on the site. In the future there will be fallback options.
			if actual_current_song != "stops":
				self.setLyricsText("Looking for lyrics....")
				self.currentLyrics = self.lyricsProg.getLatestLyrics()
				if self.currentLyrics is None:
					#Lost connect to the COM server
					self.setLyricsText("Not connected to Foobar2000's COM server, press refresh to try to connect.")
					#End the connection internally
					self.discon(forced=True)
					self.setWindowTitle("bLyrics  ::  Not Connected - Press Refresh or Connect")
					self.actionReconnect.setText(_translate("MainWindow", "Connect", None))
					#Reset the statusbar
					self.setStatusbarText("Disconnected from Foobar2000 COM Server")
					#And reset the current song
					self.currentSong = None
					
				else:
					#Set the current song name so we dont go rechecking over and over
					self.currentSong = actual_current_song
					#And now we update the lyrics page with the new lyrics if there is a song playing
					self.setLyricsText(self.currentLyrics)
					#Set the statusbar to the current song or the next song, depending on factors. See fooBarLyrics.py for more details.
					statusbar_songdata = self.lyricsProg.get_statusbar_song()
					self.setStatusbarText(statusbar_songdata)
					#We set the window title, that way the window title reflects the current track
					self.setWindowTitle("bLyrics  ::  %s - %s" % (self.lyricsProg.get_songartist()))
					
			else:
				#Foobar is currently stopped so we need to update the app to reflect this
				#First we update the lyrics pane with the info
				self.setLyricsText("Playing in Foobar2000 is currently stopped.")
				#And the window title next
				self.setWindowTitle("bLyrics  ::  Playback Stopped")
				#update the statusbar with the change
				self.setStatusbarText("Playback Stopped")
				#And lastly update self.currentSong to stops so the program knows what's up
				self.currentSong = actual_current_song

	def setLyricsText(self, lyrics):
		fontFamily, size = REsplit(",", self.fontStyle)
		fontFamily = str(fontFamily).strip()
		fontSize = str(size).strip()
		#Remove href, img, and div tags from the lyrics
		lyrics = REsub("</?a( .*?)?>", "", lyrics)
		lyrics = REsub("</?div( .*?)?>", "", lyrics)
		lyrics = REsub("</?img( .*?)?>", "", lyrics)
		html = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style="color: %s; background-color: %s; font-family:\'%s\'; font-size:%spt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">%s</p></body></html>
''' % (self.fontFgColor, self.fontBgColor, fontFamily, fontSize, lyrics)
		self.lyricsTextView.setHtml(_translate("MainWindow", html, None))

	def retranslateUi(self, MainWindow):
		self.setWindowTitle("bLyrics  ::  Not Connected")
		self.tabWidget.setTabText(self.tabWidget.indexOf(self.MainTab), _translate("MainWindow", "Current Status", None))
		self.RefreshLyricsButton.setText(_translate("MainWindow", "Refresh", None))
		self.setLyricsText("No Song Playing or Program Not Setup Properly")
		self.tabWidget.setTabText(self.tabWidget.indexOf(self.LyricsTab), _translate("MainWindow", "Lyrics", None))
		self.consoleOutput.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:8pt;\"></span></p></body></html>", None))
		self.consoleO_ClearButton.setText(_translate("MainWindow", "Clear", None))
		self.tabWidget.setTabText(self.tabWidget.indexOf(self.ConsoleTab), _translate("MainWindow", "Console", None))
		self.menuFile.setTitle(_translate("MainWindow", "File", None))
		self.subMenu.setTitle(_translate("MainWindow", "Manual song control", None))
		self.menuHelp.setTitle(_translate("MainWindow", "Help", None))
		self.aboutMenuItem.setText(_translate("MainWindow", "About", None))
		self.actionQuit.setText(_translate("MainWindow", "Quit", None))
		self.actionReconnect.setText(_translate("MainWindow", "Connect", None))
		self.actionDisconnect.setText(_translate("MainWindow", "Disconnect", None))
		self.actionClearCache.setText(_translate("MainWindow", "Clear playlist cache", None))
		self.actionOptions.setText(_translate("MainWindow", "Options", None))
		self.actionManualQuery.setText(_translate("MainWindow", "Set song manually", None))
		self.actionResetManualQuery.setText(_translate("MainWindow", "Reset manual song", None))
		self.actionSearch.setText(_translate("MainWindow", "Search for lyrics", None))
		self.Statusbar.setText(_translate("MainWindow", "Welcome to bLyrics", None))

	
	
	def setStatusbarText(self, text):
		if text is not None and len(text) > 0:
			self.Statusbar.setText(_translate("MainWindow", text, None))

	
if __name__ == "__main__":
	app = QtGui.QApplication(sys.argv)
	MainWindow = QtGui.QMainWindow()
	ui = Ui_MainWindow()
	ui.setupUi(MainWindow)
	#Hook into the app's quiting sequence so it saves our settings before it quits
	app.aboutToQuit.connect(ui.saveSettings)
	#Before we get going we get the user setting for _ALWAYS_ON_TOP
	if ui.testSettingGroup("Options") is True:
		rd = {"Advanced": ["alwaysOnTop"]}
		if ui.loadSettings(optionsMenu=True, data=rd)["Advanced"][0] == "true":
			_ALWAYS_ON_TOP_ = True
	#Set always-on-top if the user wants it
	if _ALWAYS_ON_TOP_:
		MainWindow.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint)
	MainWindow.show()
	#backup if needed later
	oldstdout = sys.stdout
	oldstderr = sys.stderr
	#Because python is a duck-typed language we can do this. All we need is the write() attribute and that's what I've given the ui class (among a bunch of unrelated methods)
	sys.stdout = ui
	sys.stderr = ui
	#And now print a special string to kickstart the console output
	print "__PROGAMINIT__"
	
	sys.exit(app.exec_())


#####################################
'''
IDEAS!

- Put our logo in the background of the about box, faded so its very lightly seen through the text.
- Splash screen while exe is unpacking for single exe?





'''